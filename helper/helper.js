import { parse, visit, Kind ,print} from 'graphql';
// import { parse, print } from 'graphql';
// import { visit } from 'graphql/language';
/**
 * Generate fragments with nested spreads for every ObjectType in your SDL.
 *
 * @param {string} sdl The contents of your .graphql typedef file
 * @returns {string}  All generated fragments joined together
 */
export function generateFragmentsFromString(sdl) {
  const ast = parse(sdl);

  // 1) First pass: collect all object type names
  const objectTypeNames = new Set();
  visit(ast, {
    ObjectTypeDefinition(node) {
      const name = node.name.value;
      if (
        !name.startsWith('__') &&
        !['Query', 'Mutation', 'Subscription'].includes(name)
      ) {
        objectTypeNames.add(name);
      }
    }
  });

  const fragments = [];

  // Helper to unwrap nested NonNullType and ListType to the named type
  function getNamedType(typeNode) {
    if (typeNode.kind === Kind.NAMED_TYPE) {
      return typeNode.name.value;
    }
    return getNamedType(typeNode.type);
  }

  // 2) Second pass: build one fragment per object type
  visit(ast, {
    ObjectTypeDefinition(node) {
      const typeName = node.name.value;
      if (!objectTypeNames.has(typeName)) return;

      const fragName = `${typeName}Fields`;
      const lines = [`fragment ${fragName} on ${typeName} {`];

      for (const field of node.fields || []) {
        const fieldName = field.name.value;
        const namedType = getNamedType(field.type);

        if (objectTypeNames.has(namedType)) {
          // nested object → emit spread
          lines.push(`  ${fieldName} { ...${namedType}Fields }`);
        } else {
          // scalar/enum → emit plain field
          lines.push(`  ${fieldName}`);
        }
      }

      lines.push(`}\n`);
      fragments.push(lines.join('\n'));
    }
  });

  return fragments.join('\n');
}



// wrapFragments.js


/**
 * Given an SDL string containing one or more `fragment X on Y { ... }` definitions,
 * returns a JS module string that:
 *   1) Imports `gql` from 'graphql-tag'
 *   2) For each fragment `FragmentName`, exports a const UPPER_SNAKE_CASE(FragmentName)
 *      wrapping exactly that fragment in a gql`...` literal.
 *
 * @param {string} multiFragmentSDL  SDL text containing multiple fragment definitions
 * @returns {string}                 A JS module you can write to a .js/.ts file
 */
export function wrapFragments(multiFragmentSDL) {
  // Parse the SDL into an AST
  const ast = parse(multiFragmentSDL);

  // Collect each fragment definition node, in order
  const fragments = [];
  visit(ast, {
    FragmentDefinition(node) {
      fragments.push(node);
    }
  });

  // Build output
  const lines = [];
  lines.push(`import { gql } from 'graphql-tag';\n`);

  for (const frag of fragments) {
    const fragName = frag.name.value;                // e.g. "CorePolicyFields"
    // convert CamelCase → UPPER_SNAKE_CASE, e.g. CorePolicyFields → CORE_POLICY_FIELDS
    const constName = fragName
      .replace(/([a-z0-9])([A-Z])/g, '$1_$2')
      .toUpperCase();

    // Print just this fragment back to SDL text
    const sdlText = print(frag).trim();

    // Emit its const
    lines.push(
      `export const ${constName} = gql\`\n${sdlText}\n\`;`
    );
  }

  return lines.join('\n');
}





// Generate GraphQL



/**
 * Generate GraphQL SDL (types + inputs) from a sample JS object.
 *
 * @param {object} sample      The object whose shape drives the typedef
 * @param {string} rootName    The name for the top‑level type (e.g. "AutogeneratedMainType")
 * @returns {string}           Complete SDL including `type`s and `input`s
 */
export function generateTypedef(sample, rootName = 'AutogeneratedMainType') {
  const typeDefs = {};
  const inputDefs = {};

  // Map JS primitives to GraphQL scalars
  const inferScalar = val => {
    if (typeof val === 'number')   return 'Int';
    if (typeof val === 'boolean')  return 'Boolean';
    return 'String';
  };

  function processObject(obj, typeName) {
    if (typeDefs[typeName]) return;        // already processed
    const fields = [];

    for (let [key, val] of Object.entries(obj)) {
      if (val === null || val === undefined) {
        fields.push(`${key}: String`);     // default fallback
      }
      else if (Array.isArray(val)) {
        if (val.length === 0) {
          // unknown element type → String
          fields.push(`${key}: [String]`);
        } else {
          const first = val[0];
          if (typeof first === 'object') {
            const childType = key.replace(/s$/, '');           // crude singular
            processObject(first, childType);
            fields.push(`${key}: [${childType}]`);
          } else {
            // scalar array
            fields.push(`${key}: [${inferScalar(first)}]`);
          }
        }
      }
      else if (typeof val === 'object') {
        // nested object
        processObject(val, key);
        fields.push(`${key}: ${key}`);
      }
      else {
        // primitive
        fields.push(`${key}: ${inferScalar(val)}`);
      }
    }

    // record type
    typeDefs[typeName] = `type ${typeName} {\n  ${fields.join('\n  ')}\n}`;

    // build matching input
    const inputFields = fields.map(line => {
      // rename field types to inpType if it's an object or object array
      let [fname, ftype] = line.split(':').map(s => s.trim());
      if (typeDefs[ftype]) {
        ftype = `inp${ftype}`;
      } else if (ftype.startsWith('[') && typeDefs[ftype.replace(/[\[\]]/g, '')]) {
        const inner = ftype.replace(/[\[\]]/g, '');
        ftype = `[inp${inner}]`;
      }
      return `${fname}: ${ftype}`;
    });
    inputDefs[`inp${typeName}`] = `input inp${typeName} {\n  ${inputFields.join('\n  ')}\n}`;
  }

  // kick off
  processObject(sample, rootName);

  // assemble SDL
  return [
    // all types
    ...Object.values(typeDefs),
    '',
    // all inputs
    ...Object.values(inputDefs),
  ].join('\n\n');
}





// Generate Stringyfied Fragment & Query 

export const cleanUpGraphQL = (content) => {
  const cleanedContent = content.trim().replace(/gql`/g, "").replace(/`/g, "");
  return cleanedContent;
};


export const extractConstants = (content) => {
  const regex = /const\s+([\w]+)\s*=\s*(.*?);/gs;
  let match;
  const constants = {
    Fragments: {},
    Queries: {},
  };

  try {
    while ((match = regex.exec(content)) !== null) {
      const variableName = match[1];
      const variableValue = match[2].trim();

      if (variableValue.toLowerCase().includes("fragment")) {
        constants.Fragments[variableName] = cleanUpGraphQL(variableValue);
      } else {
        constants.Queries[variableName] = cleanUpGraphQL(variableValue);
      }
    }
  } catch (error) {
    console.error(error);
  }
  return constants;
};



// Unstringifiy 

export const unStringify=(context)=> {

 

  // Function to clean and process query and mutation strings
  const processQuery = (str) =>
    str
      .trim()
      .replace(/\r\n/g, "\n")
      .replace(/\r/g, "\n")
      .split("\n")
      .map((l) => l.trimEnd())
      .join("\n");

  try {
    // Destructure the input body to handle Queries, Fragments, and Mutations
    const { Queries, Fragments, Mutations } = context;

    // Prepare output for Queries
    const queriesOutput = Object.entries(Queries || {})
      .map(([key, value]) => {
        const formattedQuery = processQuery(value);
        return `const ${key} = gql\`\n${formattedQuery}\n\`;`;
      })
      .join("\n\n");

    // Prepare output for Fragments (but won't inject them into mutations)
    const fragmentsOutput = Object.entries(Fragments || {})
      .map(([key, value]) => {
        const formattedFragment = processQuery(value);
        return `const ${key} = gql\`\n${formattedFragment}\n\`;`;
      })
      .join("\n\n");

    // Prepare output for Mutations (without fragment handling)
    const mutationsOutput = Object.entries(Mutations || {})
      .map(([key, value]) => {
        const formattedMutation = processQuery(value);
        return `const ${key} = gql\`\n${formattedMutation}\n\`;`;
      })
      .join("\n\n");

    // Combine all outputs
    const output = [queriesOutput, fragmentsOutput, mutationsOutput]
      .filter(Boolean)
      .join("\n\n");

   
      return output
    
  } catch (error) {
    
    console.error(`Error: ${error.message}`);
  
  }
}